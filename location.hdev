<?xml version="1.0" encoding="UTF-8"?>
<hdevelop file_version="1.2" halcon_version="18.11.0.0">
<procedure name="main">
<interface/>
<body>
<l>read_image (Image, 'E:/Projects/3d/I94/I94.bmp')</l>
<l>get_image_size (Image, Width, Height)</l>
<l>dev_close_window ()</l>
<l>dev_open_window (0, 0, 600, 800, 'black', WindowHandle)</l>
<l>attach_background_to_window (Image, WindowHandle)</l>
<l>dev_set_draw ('margin')</l>
<c></c>
<l>crossSize := 100</l>
<l>numSubRects := 10</l>
<l>ignorePortion := 0.2</l>
<c></c>
<l>findLineRects := []</l>
<c></c>
<l>GetWorldImageMap (Image, './calibration/cameraParam.cal', './calibration/cameraPos.dat', mapToImage, mapToWorld)</l>
<c></c>
<c>* find right base line</c>
<l>baseRightRow := 3318.37</l>
<l>baseRightColum := 3960.05</l>
<l>baseRightRadian := rad(180)</l>
<l>baseRightLen1 := 155.856</l>
<l>baseRightLen2 := 923.855</l>
<l>VisionProStyleFindLineOneStep (Image, rectBaseRight, 'positive', baseRightRow, baseRightColum, baseRightRadian, baseRightLen1, baseRightLen2, numSubRects, 50, 'first', ignorePortion, 'true', lineX1RightBase, lineY1RightBase, lineX2RightBase, lineY2RightBase, XsUsedRightBase, YsUsedRightBase, XsIgnoredRightBase, YsIgnoredRightBase)</l>
<c></c>
<c></c>
<c>* find top base line</c>
<l>baseTopRow := 586.07800000</l>
<l>baseTopColumn := 3025.09000000</l>
<l>baseTopRadian := rad(-91.33180000)</l>
<l>baseTopLen1 := 243.06000000</l>
<l>baseTopLen2 := 535.03500000</l>
<l>VisionProStyleFindLineOneStep (Image, rectBaseTop, 'positive', baseTopRow, baseTopColumn, baseTopRadian, baseTopLen1, baseTopLen2, numSubRects, 50, 'first', ignorePortion, 'false', lineX1TopBase, lineY1TopBase, lineX2TopBase, lineY2TopBase, XsUsedTopBase, YsUsedTopBase, XsIgnoredTopBase, YsIgnoredTopBase)</l>
<l>concat_obj (rectBaseRight, rectBaseTop, FindLineRects)</l>
<c></c>
<c>* display used and ignored points</c>
<l>dev_set_color('green')</l>
<l>tuple_concat (YsUsedRightBase, YsUsedTopBase, YsUsed)</l>
<l>tuple_concat (XsUsedRightBase, XsUsedTopBase, XsUsed)</l>
<l>gen_cross_contour_xld (CrossUsed, YsUsed, XsUsed, crossSize, 0.785398)</l>
<c></c>
<l>dev_set_color ('red')</l>
<l>tuple_concat (YsIgnoredRightBase, YsIgnoredTopBase, YsIgnored)</l>
<l>tuple_concat (XsIgnoredRightBase, XsIgnoredTopBase, XsIgnored)</l>
<l>gen_cross_contour_xld (CrossIgnored, YsIgnored, XsIgnored, crossSize, 0.785398)</l>
<c></c>
<c>* make origin</c>
<l>intersection_lines (lineY1RightBase, lineX1RightBase, lineY2RightBase, lineX2RightBase, lineY1TopBase, lineX1TopBase, lineY2TopBase, lineX2TopBase, RowOrigin, ColumnOrigin, IsOverlapping)</l>
<l>dev_set_color ('blue')</l>
<l>gen_cross_contour_xld (CrossOrigin, RowOrigin, ColumnOrigin, 200, 0.785398)</l>
<c></c>
<c></c>
<c></c>
<c></c>
<c>****************************************************FAI2***********************************</c>
<c>* make vertical grids</c>
<l>TranslateLineInWorldCoordinateAndConvertBack (lineX1RightBase, lineY1RightBase, lineX2RightBase, lineY2RightBase, 4.583, mapToWorld, mapToImage, 'true', FAI2_P1_LineStartX, FAI2_P1_LineStartY, FAI2_P1_LineEndX, FAI2_P1_LineEndY)</l>
<l>TranslateLineInWorldCoordinateAndConvertBack (lineX1RightBase, lineY1RightBase, lineX2RightBase, lineY2RightBase, 9.583, mapToWorld, mapToImage, 'true', FAI2_P2_LineStartX, FAI2_P2_LineStartY, FAI2_P2_LineEndX, FAI2_P2_LineEndY)</l>
<l>TranslateLineInWorldCoordinateAndConvertBack (lineX1RightBase, lineY1RightBase, lineX2RightBase, lineY2RightBase, 14.583, mapToWorld, mapToImage, 'true', FAI2_P3_LineStartX, FAI2_P3_LineStartY, FAI2_P3_LineEndX, FAI2_P3_LineEndY)</l>
<c></c>
<c>* make H line for FAI02</c>
<l>rectFAI2Row :=2212.92000000</l>
<l>rectFAI2Col :=2994.90000000</l>
<l>rectFAI2Radian := rad(-91.97430000)</l>
<l>rectFAI2Len1 :=60.96000000</l>
<l>rectFAI2Len2 := 520.14300000</l>
<l>gen_rectangle2 (findLineRegionFAI2, rectFAI2Row, rectFAI2Col, rectFAI2Radian, rectFAI2Len1, rectFAI2Len2)</l>
<l>concat_obj (FindLineRects, findLineRegionFAI2, FindLineRects)</l>
<c></c>
<l>reduce_domain (Image, findLineRegionFAI2, ImageReduced)</l>
<l>threshold_sub_pix (ImageReduced, Border, 128)</l>
<l>select_contours_xld (Border, SelectedContours, 'open', rectFAI2Len2-100, rectFAI2Len2, -0.5, 0.5)</l>
<l>fit_line_contour_xld (SelectedContours, 'tukey', -1, 0, 5, 2, lineStartY_FAI2H, lineStartX_FAI2H, lineEndY_FAI2H, lineEndX_FAI2H, Nr, Nc, Dist)</l>
<c>* FAI2-P1</c>
<l>intersection_lines (lineStartY_FAI2H, lineStartX_FAI2H, lineEndY_FAI2H, lineEndX_FAI2H, FAI2_P1_LineStartY, FAI2_P1_LineStartX, FAI2_P1_LineEndY, FAI2_P1_LineEndX, FAI2_P1_ROW, FAI2_P1_COL, IsOverlapping1)</l>
<l>gen_cross_contour_xld (Cross, FAI2_P1_ROW, FAI2_P1_COL, crossSize, 0.785398)</l>
<c>* FAI2-P2</c>
<l>intersection_lines (lineStartY_FAI2H, lineStartX_FAI2H, lineEndY_FAI2H, lineEndX_FAI2H, FAI2_P2_LineStartY, FAI2_P2_LineStartX, FAI2_P2_LineEndY, FAI2_P2_LineEndX, FAI2_P2_ROW, FAI2_P2_COL, IsOverlapping1)</l>
<l>gen_cross_contour_xld (Cross, FAI2_P2_ROW, FAI2_P2_COL, crossSize, 0.785398)</l>
<c>* FAI2-P3</c>
<l>intersection_lines (lineStartY_FAI2H, lineStartX_FAI2H, lineEndY_FAI2H, lineEndX_FAI2H, FAI2_P3_LineStartY, FAI2_P3_LineStartX, FAI2_P3_LineEndY, FAI2_P3_LineEndX, FAI2_P3_ROW, FAI2_P3_COL, IsOverlapping1)</l>
<l>gen_cross_contour_xld (Cross, FAI2_P3_ROW, FAI2_P3_COL, crossSize, 0.785398)</l>
<c></c>
<c>* distances</c>
<c>* P1</c>
<l>DistancePLInWorld (lineX1TopBase, lineY1TopBase, lineX2TopBase, lineY2TopBase, FAI2_P1_COL, FAI2_P1_ROW, mapToWorld, distanceWorld_P1)</l>
<c>* P2</c>
<l>DistancePLInWorld (lineX1TopBase, lineY1TopBase, lineX2TopBase, lineY2TopBase, FAI2_P2_COL, FAI2_P2_ROW, mapToWorld, distanceWorld_P2)</l>
<c>* P3</c>
<l>DistancePLInWorld (lineX1TopBase, lineY1TopBase, lineX2TopBase, lineY2TopBase, FAI2_P3_COL, FAI2_P3_ROW, mapToWorld, distanceWorld_P3)</l>
<c></c>
<c>**********************************************FAI3************************************</c>
<l>rectFAI3Row := 2310.61000000</l>
<l>rectFAI3Col := 3025.99000000</l>
<l>rectFAI3Radian := rad(88.76800000)</l>
<l>rectFAI3Len1 := 140.37300000</l>
<l>rectFAI3Len2 := 503.62100000</l>
<l>VisionProStyleFindLineOneStep (Image, rectFAI3, 'positive', rectFAI3Row, rectFAI3Col, rectFAI3Radian, rectFAI3Len1, rectFAI3Len2, numSubRects, 120, 'first', ignorePortion, 'false', lineX1FAI3, lineY1FAI3, lineX2FAI3, lineY2FAI3, XsUsedFAI3, YsUsedFAI3, XsIgnoredFAI3, YsIgnoredFAI3)</l>
<l>concat_obj (FindLineRects, rectFAI3, FindLineRects)</l>
<c></c>
<l>dev_set_color('green')</l>
<l>gen_cross_contour_xld (Cross1, YsUsedFAI3, XsUsedFAI3, crossSize, 0.785398)</l>
<l>dev_set_color ('red')</l>
<l>gen_cross_contour_xld (Cross2, YsIgnoredFAI3, XsIgnoredFAI3, crossSize, 0.785398)</l>
<c>* translate base right</c>
<l>TranslateLineInWorldCoordinateAndConvertBack (lineX1RightBase, lineY1RightBase, lineX2RightBase, lineY2RightBase, 5.299, mapToWorld, mapToImage, 'true', FAI3_P1_LineStartX, FAI3_P1_LineStartY, FAI3_P1_LineEndX, FAI3_P1_LineEndY)</l>
<l>TranslateLineInWorldCoordinateAndConvertBack (lineX1RightBase, lineY1RightBase, lineX2RightBase, lineY2RightBase, 9.299, mapToWorld, mapToImage, 'true', FAI3_P2_LineStartX, FAI3_P2_LineStartY, FAI3_P2_LineEndX, FAI3_P2_LineEndY)</l>
<l>TranslateLineInWorldCoordinateAndConvertBack (lineX1RightBase, lineY1RightBase, lineX2RightBase, lineY2RightBase, 13.299, mapToWorld, mapToImage, 'true', FAI3_P3_LineStartX, FAI3_P3_LineStartY, FAI3_P3_LineEndX, FAI3_P3_LineEndY)</l>
<c>* P1</c>
<l>dev_set_color ('blue')</l>
<l>intersection_lines (lineY1FAI3, lineX1FAI3, lineY2FAI3, lineX2FAI3, FAI3_P1_LineStartY, FAI3_P1_LineStartX, FAI3_P1_LineEndY, FAI3_P1_LineEndX, RowFAI3_P1, ColumnFAI3_P1, IsOverlapping2)</l>
<l>gen_cross_contour_xld (Cross3, RowFAI3_P1, ColumnFAI3_P1, crossSize, 0.785398)</l>
<l>DistancePLInWorld (lineX1TopBase, lineY1TopBase, lineX2TopBase, lineY2TopBase, ColumnFAI3_P1, RowFAI3_P1, mapToWorld, distanceWorld_FAI3_P1)</l>
<c>* P2</c>
<l>intersection_lines (lineY1FAI3, lineX1FAI3, lineY2FAI3, lineX2FAI3, FAI3_P2_LineStartY, FAI3_P2_LineStartX, FAI3_P2_LineEndY, FAI3_P2_LineEndX, RowFAI3_P2, ColumnFAI3_P2, IsOverlapping2)</l>
<l>gen_cross_contour_xld (Cross3, RowFAI3_P2, ColumnFAI3_P2, crossSize, 0.785398)</l>
<l>DistancePLInWorld (lineX1TopBase, lineY1TopBase, lineX2TopBase, lineY2TopBase, ColumnFAI3_P2, RowFAI3_P2, mapToWorld, distanceWorld_FAI3_P2)</l>
<c>* P3</c>
<l>intersection_lines (lineY1FAI3, lineX1FAI3, lineY2FAI3, lineX2FAI3, FAI3_P3_LineStartY, FAI3_P3_LineStartX, FAI3_P3_LineEndY, FAI3_P3_LineEndX, RowFAI3_P3, ColumnFAI3_P3, IsOverlapping2)</l>
<l>gen_cross_contour_xld (Cross3, RowFAI3_P3, ColumnFAI3_P3, crossSize, 0.785398)</l>
<l>DistancePLInWorld (lineX1TopBase, lineY1TopBase, lineX2TopBase, lineY2TopBase, ColumnFAI3_P3, RowFAI3_P3, mapToWorld, distanceWorld_FAI3_P3)</l>
<c></c>
<c></c>
<c>***********************************************FAI4*******************************</c>
<l>rectFAI4Row := 4275.51000000</l>
<l>rectFAI4Col := 2960.01000000</l>
<l>rectFAI4Radian := rad(89)</l>
<l>rectFAI4Len1 := 126.79500000</l>
<l>rectFAI4Len2 := 525.15600000</l>
<l>VisionProStyleFindLineOneStep (Image, rectFAI4, 'negative', rectFAI4Row, rectFAI4Col, rectFAI4Radian, rectFAI4Len1, rectFAI4Len2, numSubRects, 50, 'first', ignorePortion, 'false', lineX1FAI4, lineY1FAI4, lineX2FAI4, lineY2FAI4, XsUsedFAI4, YsUsedFAI4, XsIgnoredFAI4, YsIgnoredFAI4)</l>
<l>concat_obj (FindLineRects, rectFAI4, FindLineRects)</l>
<c></c>
<l>dev_set_color('green')</l>
<l>gen_cross_contour_xld (Cross1, YsUsedFAI4, XsUsedFAI4, crossSize, 0.785398)</l>
<l>dev_set_color ('red')</l>
<l>gen_cross_contour_xld (Cross2, YsIgnoredFAI4, XsIgnoredFAI4, crossSize, 0.785398)</l>
<c></c>
<l>dev_set_color ('blue')</l>
<c>* P1</c>
<l>intersection_lines (lineY1FAI4, lineX1FAI4, lineY2FAI4, lineX2FAI4, FAI3_P1_LineStartY, FAI3_P1_LineStartX, FAI3_P1_LineEndY, FAI3_P1_LineEndX, RowFAI3_P1, ColumnFAI3_P1, IsOverlapping2)</l>
<l>gen_cross_contour_xld (Cross3, RowFAI3_P1, ColumnFAI3_P1, crossSize, 0.785398)</l>
<l>DistancePLInWorld (lineX1TopBase, lineY1TopBase, lineX2TopBase, lineY2TopBase, ColumnFAI3_P1, RowFAI3_P1, mapToWorld, distanceWorld_FAI4_P1)</l>
<c>* P2</c>
<l>intersection_lines (lineY1FAI4, lineX1FAI4, lineY2FAI4, lineX2FAI4, FAI3_P2_LineStartY, FAI3_P2_LineStartX, FAI3_P2_LineEndY, FAI3_P2_LineEndX, RowFAI3_P2, ColumnFAI3_P2, IsOverlapping2)</l>
<l>gen_cross_contour_xld (Cross3, RowFAI3_P2, ColumnFAI3_P2, crossSize, 0.785398)</l>
<l>DistancePLInWorld (lineX1TopBase, lineY1TopBase, lineX2TopBase, lineY2TopBase, ColumnFAI3_P2, RowFAI3_P2, mapToWorld, distanceWorld_FAI4_P2)</l>
<c>* P3</c>
<l>intersection_lines (lineY1FAI4, lineX1FAI4, lineY2FAI4, lineX2FAI4, FAI3_P3_LineStartY, FAI3_P3_LineStartX, FAI3_P3_LineEndY, FAI3_P3_LineEndX, RowFAI3_P3, ColumnFAI3_P3, IsOverlapping2)</l>
<l>gen_cross_contour_xld (Cross3, RowFAI3_P3, ColumnFAI3_P3, crossSize, 0.785398)</l>
<l>DistancePLInWorld (lineX1TopBase, lineY1TopBase, lineX2TopBase, lineY2TopBase, ColumnFAI3_P3, RowFAI3_P3, mapToWorld, distanceWorld_FAI4_P3)</l>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<l>dev_set_color ('yellow')</l>
<l>dev_display (FindLineRects)</l>
</body>
<docu id="main">
<parameters/>
</docu>
</procedure>
<procedure name="GenVisibleMeasureRect">
<interface>
<oo>
<par name="ROI_0" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="rect1_row" base_type="ctrl" dimension="0"/>
<par name="rect1_col" base_type="ctrl" dimension="0"/>
<par name="rect1_rad" base_type="ctrl" dimension="0"/>
<par name="rect1_len1" base_type="ctrl" dimension="0"/>
<par name="rect1_len2" base_type="ctrl" dimension="0"/>
<par name="Width" base_type="ctrl" dimension="0"/>
<par name="Height" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="MeasureHandle" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>gen_rectangle2 (ROI_0, rect1_row, rect1_col, rect1_rad, rect1_len1, rect1_len2)</l>
<l>gen_measure_rectangle2 (rect1_row, rect1_col, rect1_rad, rect1_len1, rect1_len2, Width, Height, 'nearest_neighbor', MeasureHandle)</l>
<l>return ()</l>
</body>
<docu id="GenVisibleMeasureRect">
<parameters>
<parameter id="Height"/>
<parameter id="MeasureHandle"/>
<parameter id="ROI_0"/>
<parameter id="Width"/>
<parameter id="rect1_col"/>
<parameter id="rect1_len1"/>
<parameter id="rect1_len2"/>
<parameter id="rect1_rad"/>
<parameter id="rect1_row"/>
</parameters>
</docu>
</procedure>
<procedure name="VisionProStyleFindLine">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ROI_0" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="transition" base_type="ctrl" dimension="0"/>
<par name="rect1_row" base_type="ctrl" dimension="0"/>
<par name="rect1_col" base_type="ctrl" dimension="0"/>
<par name="rect1_rad" base_type="ctrl" dimension="0"/>
<par name="rect1_len1" base_type="ctrl" dimension="0"/>
<par name="rect1_len2" base_type="ctrl" dimension="0"/>
<par name="numSubRects" base_type="ctrl" dimension="0"/>
<par name="threshold" base_type="ctrl" dimension="0"/>
<par name="firstOrLast" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Xs" base_type="ctrl" dimension="0"/>
<par name="Ys" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<l>Xs := []</l>
<l>Ys := []</l>
<c></c>
<c></c>
<l>get_image_size (Image, Width, Height)</l>
<c></c>
<c></c>
<l>leftFaced := rect1_rad&lt;rad(-90) or rect1_rad&gt;rad(90)</l>
<l>rect1_deg := deg(rect1_rad)</l>
<c></c>
<l>gen_rectangle2 (ROI_0, rect1_row, rect1_col, rect1_rad, rect1_len1, rect1_len2)</l>
<l>numSubRects := 10</l>
<l>widthSubRects := rect1_len2/numSubRects*2</l>
<l>heightSubRects := rect1_len1*2</l>
<c></c>
<l>if(leftFaced)</l>
<l>    betaDeg := -rect1_deg - 90</l>
<l>rectStartX := rect1_col - rect1_len2 * cos(rad(betaDeg))</l>
<l>rectStartY := rect1_row - rect1_len2 * sin(rad(betaDeg))</l>
<l>subRectXIncrement := widthSubRects * cos(rad(betaDeg))</l>
<l>subRectYIncrement := sqrt(widthSubRects*widthSubRects-subRectXIncrement*subRectXIncrement)</l>
<l>firstSubRectCenterX := rectStartX + subRectXIncrement*0.5</l>
<l>firstSubRectCenterY := rectStartY + subRectYIncrement * 0.5</l>
<l>else</l>
<l>    betaDeg := 90 + rect1_deg</l>
<l>rectStartX := rect1_col + rect1_len2 * cos(rad(betaDeg))</l>
<l>rectStartY := rect1_row - rect1_len2 * sin(rad(betaDeg))</l>
<l>subRectXIncrement := -widthSubRects * cos(rad(betaDeg))</l>
<l>subRectYIncrement := sqrt(widthSubRects*widthSubRects-subRectXIncrement*subRectXIncrement)</l>
<l>firstSubRectCenterX := rectStartX + subRectXIncrement*0.5</l>
<l>firstSubRectCenterY := rectStartY + subRectYIncrement * 0.5</l>
<l>endif</l>
<c></c>
<c></c>
<l>for Index := 0 to numSubRects-1 by 1</l>
<c>    </c>
<l>    if(leftFaced)</l>
<l>         subRectCenterX := firstSubRectCenterX + Index*subRectXIncrement</l>
<l>   subRectCenterY := firstSubRectCenterY + Index*subRectYIncrement </l>
<l>   subRectLen1 := rect1_len1</l>
<l>   subRectLen2 := rect1_len2/numSubRects</l>
<l>   subRectPhi := rect1_rad</l>
<l>    else</l>
<l>           subRectCenterX := firstSubRectCenterX + Index*subRectXIncrement</l>
<l>   subRectCenterY := firstSubRectCenterY + Index*subRectYIncrement </l>
<l>   subRectLen1 := rect1_len1</l>
<l>   subRectLen2 := rect1_len2/numSubRects</l>
<l>   subRectPhi := rect1_rad</l>
<l>    endif</l>
<c>    </c>
<l>   gen_rectangle2 (Rectangle, subRectCenterY, subRectCenterX, subRectPhi, subRectLen1, subRectLen2)</l>
<l>   gen_measure_rectangle2 (subRectCenterY, subRectCenterX, subRectPhi, subRectLen1, subRectLen2, Width, Height, 'nearest_neighbor', MeasureHandle1)</l>
<l>   measure_pos (Image, MeasureHandle1, 1, threshold, transition, firstOrLast, RowEdge1, ColumnEdge1, Amplitude1, Distance1)</l>
<l>   Xs := [Xs,ColumnEdge1]</l>
<l>   Ys := [Ys, RowEdge1]</l>
<l>   close_measure (MeasureHandle1)</l>
<l>endfor</l>
<c></c>
<c></c>
<l>return ()</l>
</body>
<docu id="VisionProStyleFindLine">
<parameters>
<parameter id="Image"/>
<parameter id="ROI_0"/>
<parameter id="Xs"/>
<parameter id="Ys"/>
<parameter id="firstOrLast"/>
<parameter id="numSubRects"/>
<parameter id="rect1_col"/>
<parameter id="rect1_len1"/>
<parameter id="rect1_len2"/>
<parameter id="rect1_rad"/>
<parameter id="rect1_row"/>
<parameter id="threshold"/>
<parameter id="transition"/>
</parameters>
</docu>
</procedure>
<procedure name="FitLine2D">
<interface>
<ic>
<par name="Xs" base_type="ctrl" dimension="0"/>
<par name="Ys" base_type="ctrl" dimension="0"/>
<par name="ignorePortion" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="lineX1" base_type="ctrl" dimension="0"/>
<par name="lineY1" base_type="ctrl" dimension="0"/>
<par name="lineX2" base_type="ctrl" dimension="0"/>
<par name="lineY2" base_type="ctrl" dimension="0"/>
<par name="XsUsed" base_type="ctrl" dimension="0"/>
<par name="YsUsed" base_type="ctrl" dimension="0"/>
<par name="XsIgnored" base_type="ctrl" dimension="0"/>
<par name="YsIgnored" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>fit_line2D_rough (Xs, Ys, lineX1, lineY1, lineX2, lineY2)</l>
<c></c>
<l>totalPoints := |Xs|</l>
<c>* number of points to ignore</c>
<l>numPointsLeft := (1.0-ignorePortion) * |Xs|</l>
<c></c>
<c>* calculate fitness of each point</c>
<l>fiterrors := []</l>
<l>for i := 0 to |Xs|-1 by 1</l>
<l>    distance_pl (Ys[i], Xs[i], lineY1, lineX1, lineY2, lineX2, Distance)</l>
<l>    fiterrors := [fiterrors, Distance]</l>
<l>endfor</l>
<c></c>
<l>tuple_sort_index (fiterrors, Indices)</l>
<c></c>
<c>* select the best fits</c>
<l>XsUsed := []</l>
<l>YsUsed := []</l>
<l>XsIgnored := []</l>
<l>YsIgnored := []</l>
<l>ErrorBest := []</l>
<l>for i := 0 to totalPoints-1 by 1</l>
<l>    index := Indices[i]</l>
<l>   if(i &lt; numPointsLeft)</l>
<l>           XsUsed := [XsUsed, Xs[index]]</l>
<l>    YsUsed := [YsUsed, Ys[index]]</l>
<l>    ErrorBest := [ErrorBest, fiterrors[index]]</l>
<l>   else</l>
<l>       XsIgnored := [XsIgnored, Xs[index]]</l>
<l>       YsIgnored := [YsIgnored, Ys[index]]</l>
<l>   endif</l>
<l>endfor</l>
<c></c>
<c>* fit line again</c>
<l>fit_line2D_rough (XsUsed, YsUsed, lineX1, lineY1, lineX2, lineY2)</l>
<c></c>
<c></c>
<l>return ()</l>
</body>
<docu id="FitLine2D">
<parameters>
<parameter id="Xs"/>
<parameter id="XsIgnored"/>
<parameter id="XsUsed"/>
<parameter id="Ys"/>
<parameter id="YsIgnored"/>
<parameter id="YsUsed"/>
<parameter id="ignorePortion"/>
<parameter id="lineX1"/>
<parameter id="lineX2"/>
<parameter id="lineY1"/>
<parameter id="lineY2"/>
</parameters>
</docu>
</procedure>
<procedure name="move_point_along_line">
<interface>
<ic>
<par name="lineStartX" base_type="ctrl" dimension="0"/>
<par name="lineStartY" base_type="ctrl" dimension="0"/>
<par name="lineDirectionX" base_type="ctrl" dimension="0"/>
<par name="lineDirectionY" base_type="ctrl" dimension="0"/>
<par name="distance" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="lineMovedX" base_type="ctrl" dimension="0"/>
<par name="lineMovedY" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>xDiff := lineDirectionX - lineStartX</l>
<l>yDiff := lineDirectionY - lineStartY</l>
<l>totalDiff := sqrt(yDiff*yDiff+xDiff*xDiff)</l>
<l>xDirection := xDiff / totalDiff</l>
<l>yDirection := yDiff / totalDiff</l>
<l>lineMovedX := lineStartX + xDirection * distance</l>
<l>lineMovedY := lineStartY + yDirection * distance</l>
<l>return ()</l>
</body>
<docu id="move_point_along_line">
<parameters>
<parameter id="distance"/>
<parameter id="lineDirectionX"/>
<parameter id="lineDirectionY"/>
<parameter id="lineMovedX"/>
<parameter id="lineMovedY"/>
<parameter id="lineStartX"/>
<parameter id="lineStartY"/>
</parameters>
</docu>
</procedure>
<procedure name="get_perpendicular_line_that_passes">
<interface>
<ic>
<par name="lineXStart" base_type="ctrl" dimension="0"/>
<par name="lineYStart" base_type="ctrl" dimension="0"/>
<par name="lineXEnd" base_type="ctrl" dimension="0"/>
<par name="lineYEnd" base_type="ctrl" dimension="0"/>
<par name="xPass" base_type="ctrl" dimension="0"/>
<par name="yPass" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="lineXPerpendicular" base_type="ctrl" dimension="0"/>
<par name="lineYPerpendicular" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>get_direction_unit (lineXStart, lineYStart, lineXEnd, lineYEnd, xUnit, yUnit)</l>
<l>get_perpendicular_direction (xUnit, yUnit, outputVectorX, outputVectorY)</l>
<c></c>
<c>* another point on the perpendicular line can be determined by</c>
<c>* adding perpendicular unit vector to the first point that we passed</c>
<l>lineXPerpendicular := xPass + outputVectorX</l>
<l>lineYPerpendicular := yPass + outputVectorY</l>
<c></c>
<l>return ()</l>
</body>
<docu id="get_perpendicular_line_that_passes">
<parameters>
<parameter id="lineXEnd"/>
<parameter id="lineXPerpendicular"/>
<parameter id="lineXStart"/>
<parameter id="lineYEnd"/>
<parameter id="lineYPerpendicular"/>
<parameter id="lineYStart"/>
<parameter id="xPass"/>
<parameter id="yPass"/>
</parameters>
</docu>
</procedure>
<procedure name="get_direction_unit">
<interface>
<ic>
<par name="xStart" base_type="ctrl" dimension="0"/>
<par name="yStart" base_type="ctrl" dimension="0"/>
<par name="xEnd" base_type="ctrl" dimension="0"/>
<par name="yEnd" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="xUnit" base_type="ctrl" dimension="0"/>
<par name="yUnit" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>xDiff := xEnd - xStart</l>
<l>yDiff := yEnd - yStart</l>
<c></c>
<l>totalDiff := sqrt(yDiff*yDiff + xDiff*xDiff)</l>
<c></c>
<l>xUnit := xDiff / totalDiff</l>
<l>yUnit := yDiff / totalDiff</l>
<c></c>
<l>return ()</l>
</body>
<docu id="get_direction_unit">
<parameters>
<parameter id="xEnd"/>
<parameter id="xStart"/>
<parameter id="xUnit"/>
<parameter id="yEnd"/>
<parameter id="yStart"/>
<parameter id="yUnit"/>
</parameters>
</docu>
</procedure>
<procedure name="get_perpendicular_direction">
<interface>
<ic>
<par name="inputVectorX" base_type="ctrl" dimension="0"/>
<par name="inputVectorY" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="outputVectorX" base_type="ctrl" dimension="0"/>
<par name="outputVectorY" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* assume that a perticular vector perpendiclar to me is (xAssume, yAssume), let xAssume = 1</c>
<l>xAssume := 1</l>
<l>yAssume := -(inputVectorX/inputVectorY)</l>
<l>distAssume := sqrt(yAssume*yAssume + xAssume * xAssume)</l>
<c></c>
<c>* calculate unit length direction vector</c>
<l>outputVectorX := xAssume / distAssume</l>
<l>outputVectorY := yAssume / distAssume</l>
<c></c>
<l>return ()</l>
</body>
<docu id="get_perpendicular_direction">
<parameters>
<parameter id="inputVectorX"/>
<parameter id="inputVectorY"/>
<parameter id="outputVectorX"/>
<parameter id="outputVectorY"/>
</parameters>
</docu>
</procedure>
<procedure name="offset_line">
<interface>
<ic>
<par name="x1" base_type="ctrl" dimension="0"/>
<par name="y1" base_type="ctrl" dimension="0"/>
<par name="x2" base_type="ctrl" dimension="0"/>
<par name="y2" base_type="ctrl" dimension="0"/>
<par name="offset" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="x1Output" base_type="ctrl" dimension="0"/>
<par name="y1Output" base_type="ctrl" dimension="0"/>
<par name="x2Output" base_type="ctrl" dimension="0"/>
<par name="y2Output" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* calculate m and b</c>
<l>xDiff := x2 - x1</l>
<l>yDiff := y2 - y1</l>
<l>m := yDiff / xDiff</l>
<l>b := y1 - m* x1</l>
<c></c>
<c>* calculate angle</c>
<l>radian := atan(m)</l>
<c>* calculate new b after offset</c>
<l>yIncre := offset / cos(radian)</l>
<l>newB := b + yIncre</l>
<c></c>
<c>* sample two points back to caller</c>
<l>x1Output := x1</l>
<l>x2Output := x2</l>
<l>y1Output := x1Output * m + newB</l>
<l>y2Output := x2Output * m + newB</l>
<c></c>
<l>return ()</l>
</body>
<docu id="offset_line">
<parameters>
<parameter id="offset"/>
<parameter id="x1"/>
<parameter id="x1Output"/>
<parameter id="x2"/>
<parameter id="x2Output"/>
<parameter id="y1"/>
<parameter id="y1Output"/>
<parameter id="y2"/>
<parameter id="y2Output"/>
</parameters>
</docu>
</procedure>
<procedure name="I40_FindOrigin">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="FindLineRegions" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="ModelID" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="VAxisX1" base_type="ctrl" dimension="0"/>
<par name="VAxisY1" base_type="ctrl" dimension="0"/>
<par name="VAxisX2" base_type="ctrl" dimension="0"/>
<par name="VAxisY2" base_type="ctrl" dimension="0"/>
<par name="HAxisX1" base_type="ctrl" dimension="0"/>
<par name="HAxisY1" base_type="ctrl" dimension="0"/>
<par name="HAxisX2" base_type="ctrl" dimension="0"/>
<par name="HAxisY2" base_type="ctrl" dimension="0"/>
<par name="CoorCenterY" base_type="ctrl" dimension="0"/>
<par name="CoorCenterX" base_type="ctrl" dimension="0"/>
<par name="XsUsed" base_type="ctrl" dimension="0"/>
<par name="YsUsed" base_type="ctrl" dimension="0"/>
<par name="XsIgnored" base_type="ctrl" dimension="0"/>
<par name="YsIgnored" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>Width := 2032</l>
<l>Height := 2500</l>
<c></c>
<l>xCoeff := 0.016</l>
<l>yCoeff := 0.02</l>
<c></c>
<c>* create xld features for fixturing</c>
<l>gen_rectangle1 (ROI_0, 99.0277, 161.153, 1198.89, 1388.46)</l>
<l>reduce_domain (Image, ROI_0, ImageReduced)</l>
<l>sobel_amp (ImageReduced, EdgeAmplitude, 'sum_abs', 3)</l>
<l>threshold (EdgeAmplitude, Region, 0.5, 255)</l>
<l>region_to_bin (Region, BinImage, 255, 0, Width, Height)</l>
<l>gen_contour_region_xld (Region, Contours, 'border')</l>
<c></c>
<l>find_shape_model (BinImage, ModelID, -0.39, 0.79, 0.5, 1, 0.5, 'least_squares', 0, 0.9, Row5, Column5, Angle, Score)</l>
<l>vector_angle_to_rigid (0, 0, 0, Row5, Column5, Angle, HomMat2D)</l>
<c></c>
<c>* center of the model</c>
<l>area_center (Region, Area1, centerModelY, centerModelX)</l>
<c></c>
<c>* align all the measure rects with respect to the created shape model which is zero centered</c>
<l>set_system ('clip_region', 'false')</l>
<c>* upperleft find line</c>
<l>*gen_rectangle2 (Rectangle, 331.86700000, 510.16200000, rad(-90.00000000), 40, 90.95780000)</l>
<l>*move_region (Rectangle, RegionMoved, -centerModelY, -centerModelX)</l>
<c>* upper right find line</c>
<l>gen_rectangle2 (Rectangle1, 1676.14, 792.335, rad(90), 60, 220)</l>
<l>move_region (Rectangle1, RegionMoved1, -centerModelY, -centerModelX)</l>
<c>* left upper find line</c>
<l>gen_rectangle2 (Rectangle2, 477.38200000, 370.80400000, rad(0.00000000), 60, 75.89940000)</l>
<l>move_region (Rectangle2, RegionMoved2, -centerModelY, -centerModelX)</l>
<c>* left lower find line</c>
<l>gen_rectangle2 (Rectangle3, 897.15300000, 368.12700000, rad(0.00000000), 60, 48.35380000)</l>
<l>move_region (Rectangle3, RegionMoved3, -centerModelY, -centerModelX)</l>
<l>set_system ('clip_region', 'true')</l>
<c></c>
<c></c>
<c>* fix all the measure rects to track individual parts to be measured</c>
<l>*affine_trans_region (RegionMoved, FindLineRegions, HomMat2D, 'nearest_neighbor')</l>
<l>affine_trans_region (RegionMoved1, FindLineRegions, HomMat2D, 'nearest_neighbor')</l>
<l>affine_trans_region (RegionMoved2, FindLineRegions2, HomMat2D, 'nearest_neighbor')</l>
<l>affine_trans_region (RegionMoved3, FindLineRegions3, HomMat2D, 'nearest_neighbor')</l>
<c></c>
<c>* get the pose of measure rects that are fixed in place</c>
<l>*smallest_rectangle2 (FindLineRegions, Row1, Column1, Phi, Length1, Length2)</l>
<l>smallest_rectangle2 (FindLineRegions, Row2, Column2, Phi1, Length11, Length21)</l>
<l>smallest_rectangle2 (FindLineRegions2, Row3, Column3, Phi2, Length12, Length22)</l>
<l>smallest_rectangle2 (FindLineRegions3, Row4, Column4, Phi3, Length13, Length23)</l>
<c></c>
<c>* find all the points within the above rects</c>
<l>* VisionProStyleFindLine (Image, ROI_0, 'positive', Row1, Column1, rad(-90), Length2, Length1, 8, threshold, firstOrLast, XsUpperLeft, YsUpperLeft)</l>
<l>VisionProStyleFindLine (Image, ROI_0, 'negative', Row2, Column2, rad(-90), Length21, Length11, 8, threshold1, firstOrLast1, XsUpperRight, YsUpperRight)</l>
<l>VisionProStyleFindLine (Image, ROI_0, 'positive', Row3, Column3, rad(0), Length22, Length12, 8, threshold2, firstOrLast2, XsLeftUpper, YsLeftUpper)</l>
<l>VisionProStyleFindLine (Image, ROI_0, 'positive', Row4, Column4, rad(0), Length13, Length23, 8, threshold3, firstOrLast3, XsLeftLower, YsLeftLower)</l>
<c></c>
<c>* fit left and upper base line</c>
<l>*tuple_concat (XsUpperLeft, XsUpperRight, XsUpper)</l>
<l>*tuple_concat (YsUpperLeft, YsUpperRight, YsUpper)</l>
<l>tuple_concat (XsLeftUpper, XsLeftLower, XsLeft)</l>
<l>tuple_concat (YsLeftUpper, YsLeftLower, YsLeft)</l>
<c></c>
<l>ignorePortion := 0.2</l>
<l>FitLine2D (XsUpperRight, YsUpperRight, ignorePortion, lineX1Horizontal, lineY1Horizontal, lineX2Horizontal, lineY2Horizontal, XsUsed1, YsUsed1, XsIgnored1, YsIgnored1)</l>
<l>FitLine2D (YsLeft, XsLeft, ignorePortion, lineY1Vertical, lineX1Vertical, lineY2Vertical, lineX2Vertical, YsUsed2, XsUsed2, YsIgnored2, XsIgnored2)</l>
<c></c>
<l>tuple_concat (XsUsed1, XsUsed2, XsUsed)</l>
<l>tuple_concat (YsUsed1, YsUsed2, YsUsed)</l>
<l>tuple_concat (XsIgnored1, XsIgnored2, XsIgnored)</l>
<l>tuple_concat (YsIgnored1,YsIgnored2, YsIgnored)</l>
<c></c>
<l>intersection_lines (lineY1Vertical, lineX1Vertical, lineY2Vertical, lineX2Vertical, lineY1Horizontal, lineX1Horizontal, lineY2Horizontal, lineX2Horizontal, Row, Column, IsOverlapping)</l>
<c></c>
<c>* move the intersection point from top left to top center</c>
<l>move_point_along_line (Column, Row, lineX1Horizontal, lineY1Horizontal, 6.74/xCoeff, VAxisX1, VAxisY1)</l>
<l>gen_cross_contour_xld (PointsFound4, VAxisY1, VAxisX1, 100, Angle)</l>
<c></c>
<c>* the perpendicular can be determined by the last four params</c>
<l>get_perpendicular_line_that_passes (lineX1Horizontal, lineY1Horizontal, VAxisX1, VAxisY1, VAxisX1, VAxisY1, VAxisX2, VAxisY2)</l>
<c></c>
<c>* offset the horizontal line</c>
<l>offset_line(lineX1Horizontal, lineY1Horizontal, lineX2Horizontal, lineY2Horizontal, -19.47/yCoeff, HAxisX1, HAxisY1, HAxisX2, HAxisY2)</l>
<c></c>
<c>* draw new coordinate center</c>
<l>intersection_lines (VAxisY1, VAxisX1, VAxisY2, VAxisX2, HAxisY1, HAxisX1, HAxisY2, HAxisX2, CoorCenterY, CoorCenterX, IsOverlapping1)</l>
<l>gen_cross_contour_xld (PointsFound5, CoorCenterY, CoorCenterX, 100, Angle)</l>
<c></c>
<c></c>
<c>* concat objects necessary for displaying</c>
<l>concat_obj (FindLineRegions, FindLineRegions2, FindLineRegions)</l>
<l>concat_obj (FindLineRegions, FindLineRegions3, FindLineRegions)</l>
<l>return ()</l>
</body>
<docu id="I40_FindOrigin">
<parameters>
<parameter id="CoorCenterX"/>
<parameter id="CoorCenterY"/>
<parameter id="FindLineRegions"/>
<parameter id="HAxisX1"/>
<parameter id="HAxisX2"/>
<parameter id="HAxisY1"/>
<parameter id="HAxisY2"/>
<parameter id="Image"/>
<parameter id="ModelID"/>
<parameter id="VAxisX1"/>
<parameter id="VAxisX2"/>
<parameter id="VAxisY1"/>
<parameter id="VAxisY2"/>
<parameter id="XsIgnored"/>
<parameter id="XsUsed"/>
<parameter id="YsIgnored"/>
<parameter id="YsUsed"/>
</parameters>
</docu>
</procedure>
<procedure name="fit_line2D_rough">
<interface>
<ic>
<par name="Xs" base_type="ctrl" dimension="0"/>
<par name="Ys" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="lineX1" base_type="ctrl" dimension="0"/>
<par name="lineY1" base_type="ctrl" dimension="0"/>
<par name="lineX2" base_type="ctrl" dimension="0"/>
<par name="lineY2" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>tuple_sum (Xs, SumX)</l>
<l>AverageX := SumX / |Xs|</l>
<c></c>
<l>tuple_sum (Ys, SumY)</l>
<l>AverageY := SumY / |Ys|</l>
<c></c>
<l>SumUpper := 0</l>
<l>SumLower := 0</l>
<l>for i := 0 to |Xs|-1 by 1</l>
<l>    incrementUpper := (Xs[i]-AverageX) * (Ys[i]-AverageY)</l>
<l>    incrementLower := (AverageX-Xs[i]) * (AverageX-Xs[i])</l>
<l>    SumUpper := SumUpper + incrementUpper</l>
<l>    SumLower := SumLower + incrementLower</l>
<l>endfor</l>
<c></c>
<l>m := SumUpper / SumLower</l>
<l>b := AverageY - m*AverageX </l>
<c></c>
<c></c>
<c></c>
<c>* sample two point</c>
<l>tuple_max (Xs, lineX1)</l>
<l>tuple_min (Xs, lineX2)</l>
<c></c>
<l>lineY1 := m * lineX1 + b</l>
<l>lineY2 := m * lineX2 + b</l>
<l>return ()</l>
</body>
<docu id="fit_line2D_rough">
<parameters>
<parameter id="Xs"/>
<parameter id="Ys"/>
<parameter id="lineX1"/>
<parameter id="lineX2"/>
<parameter id="lineY1"/>
<parameter id="lineY2"/>
</parameters>
</docu>
</procedure>
<procedure name="VisionProStyleFindLineOneStep">
<interface>
<io>
<par name="inputImage" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="findLineRegion" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="transition" base_type="ctrl" dimension="0"/>
<par name="row" base_type="ctrl" dimension="0"/>
<par name="col" base_type="ctrl" dimension="0"/>
<par name="radian" base_type="ctrl" dimension="0"/>
<par name="len1" base_type="ctrl" dimension="0"/>
<par name="len2" base_type="ctrl" dimension="0"/>
<par name="numSubRects" base_type="ctrl" dimension="0"/>
<par name="threshold" base_type="ctrl" dimension="0"/>
<par name="firstOrLast" base_type="ctrl" dimension="0"/>
<par name="ignoreFraction" base_type="ctrl" dimension="0"/>
<par name="isVertical" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="lineX1" base_type="ctrl" dimension="0"/>
<par name="lineY1" base_type="ctrl" dimension="0"/>
<par name="lineX2" base_type="ctrl" dimension="0"/>
<par name="lineY2" base_type="ctrl" dimension="0"/>
<par name="XsUsed" base_type="ctrl" dimension="0"/>
<par name="YsUsed" base_type="ctrl" dimension="0"/>
<par name="XsIgnored" base_type="ctrl" dimension="0"/>
<par name="YsIgnored" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>VisionProStyleFindLine (inputImage, findLineRegion,transition,row,col,radian,len1,len2,numSubRects,threshold,firstOrLast, Xs, Ys)</l>
<c></c>
<c></c>
<l>if(isVertical == 'true')</l>
<l>    FitLine2D (Ys, Xs, ignoreFraction, lineY1, lineX1, lineY2, lineX2, YsUsed, XsUsed, YsIgnored, XsIgnored)</l>
<l>else</l>
<l>        FitLine2D (Xs, Ys, ignoreFraction, lineX1, lineY1, lineX2, lineY2, XsUsed, YsUsed, XsIgnored, YsIgnored)</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="VisionProStyleFindLineOneStep">
<parameters>
<parameter id="XsIgnored"/>
<parameter id="XsUsed"/>
<parameter id="YsIgnored"/>
<parameter id="YsUsed"/>
<parameter id="col"/>
<parameter id="findLineRegion"/>
<parameter id="firstOrLast"/>
<parameter id="ignoreFraction"/>
<parameter id="inputImage"/>
<parameter id="isVertical"/>
<parameter id="len1"/>
<parameter id="len2"/>
<parameter id="lineX1"/>
<parameter id="lineX2"/>
<parameter id="lineY1"/>
<parameter id="lineY2"/>
<parameter id="numSubRects"/>
<parameter id="radian"/>
<parameter id="row"/>
<parameter id="threshold"/>
<parameter id="transition"/>
</parameters>
</docu>
</procedure>
<procedure name="GetWorldImageMap">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="camParamFile" base_type="ctrl" dimension="0"/>
<par name="camPoseFile" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="mapToImage" base_type="ctrl" dimension="0"/>
<par name="mapToWorld" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>read_pose (camPoseFile, Pose)</l>
<l>read_cam_par (camParamFile, CameraParam)</l>
<l>get_image_size (Image, Width, Height)</l>
<c></c>
<c>* generate 9 image-to-world coordinate pairs</c>
<l>XsImage := []</l>
<l>YsImage := []</l>
<l>XsWorld := []</l>
<l>YsWorld := []</l>
<c></c>
<l>for row := -1 to 1 by 1</l>
<l>    for column := -1 to 1 by 1</l>
<l>        xImage := Width/2 + 100* column</l>
<l>        XsImage := [XsImage, xImage]</l>
<l>        yImage := Height/2 + 100 * row</l>
<l>        YsImage := [YsImage, yImage]</l>
<c>        </c>
<l>        image_points_to_world_plane (CameraParam, Pose, yImage, xImage, 'mm', xWorld, yWorld)</l>
<l>        XsWorld := [XsWorld, xWorld]</l>
<l>        YsWorld := [YsWorld, yWorld]</l>
<l>    endfor</l>
<l>endfor</l>
<c></c>
<l>vector_to_similarity (XsWorld, YsWorld, XsImage, YsImage, mapToImage)</l>
<l>vector_to_similarity (XsImage, YsImage, XsWorld, YsWorld, mapToWorld)</l>
<c></c>
<c></c>
<l>return ()</l>
</body>
<docu id="GetWorldImageMap">
<parameters>
<parameter id="Image">
<description lang="zh_CN">Getting maps that convert image coordintates to and from world</description>
</parameter>
<parameter id="camParamFile">
<sem_type>string</sem_type>
</parameter>
<parameter id="camPoseFile">
<sem_type>string</sem_type>
</parameter>
<parameter id="mapToImage"/>
<parameter id="mapToWorld"/>
</parameters>
</docu>
</procedure>
<procedure name="GetImageToWorldMap">
<interface>
<io>
<par name="image" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="camParamFile" base_type="ctrl" dimension="0"/>
<par name="camPoseFile" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="map" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>read_pose (camPoseFile, Pose)</l>
<l>read_cam_par (camParamFile, CameraParam)</l>
<l>get_image_size (image, Width, Height)</l>
<c></c>
<c>* generate 9 image-to-world coordinate pairs</c>
<l>XsImage := []</l>
<l>YsImage := []</l>
<l>XsWorld := []</l>
<l>YsWorld := []</l>
<c></c>
<l>for row := -1 to 1 by 1</l>
<l>    for column := -1 to 1 by 1</l>
<l>        xImage := Width/2 + 100* column</l>
<l>        XsImage := [XsImage, xImage]</l>
<l>        yImage := Height/2 + 100 * row</l>
<l>        YsImage := [YsImage, yImage]</l>
<c>        </c>
<l>        image_points_to_world_plane (CameraParam, Pose, yImage, xImage, 'mm', xWorld, yWorld)</l>
<l>        XsWorld := [XsWorld, xWorld]</l>
<l>        YsWorld := [YsWorld, yWorld]</l>
<l>    endfor</l>
<l>endfor</l>
<c></c>
<l>vector_to_similarity (XsImage, YsImage, XsWorld, YsWorld, map)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="GetImageToWorldMap">
<parameters>
<parameter id="camParamFile"/>
<parameter id="camPoseFile"/>
<parameter id="image"/>
<parameter id="map"/>
</parameters>
</docu>
</procedure>
<procedure name="TranslateLineInWorldCoordinateAndConvertBack">
<interface>
<ic>
<par name="lineStartX" base_type="ctrl" dimension="0"/>
<par name="lineStartY" base_type="ctrl" dimension="0"/>
<par name="lineEndX" base_type="ctrl" dimension="0"/>
<par name="lineEndY" base_type="ctrl" dimension="0"/>
<par name="distance" base_type="ctrl" dimension="0"/>
<par name="mapToWorld" base_type="ctrl" dimension="0"/>
<par name="mapToImage" base_type="ctrl" dimension="0"/>
<par name="isVertical" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="outLineStartX" base_type="ctrl" dimension="0"/>
<par name="outLineStartY" base_type="ctrl" dimension="0"/>
<par name="outLineEndX" base_type="ctrl" dimension="0"/>
<par name="outLineEndY" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* convert image line to world line</c>
<l>affine_trans_point_2d (mapToWorld, lineStartX, lineStartY, lineStartX_World, lineStartY_World)</l>
<l>affine_trans_point_2d (mapToWorld, lineEndX, lineEndY, lineEndX_World, lineEndY_World)</l>
<c></c>
<c>* translate world line</c>
<l>MakeParallelLine (lineStartX_World, lineStartY_World, lineEndX_World, lineEndY_World, distance, isVertical, outLineStartX, outLineStartY, outLineEndX, outLineEndY)</l>
<c></c>
<c>* convert world line back to image line</c>
<l>affine_trans_point_2d (mapToImage, outLineStartX, outLineStartY, outLineStartX, outLineStartY)</l>
<l>affine_trans_point_2d (mapToImage, outLineEndX, outLineEndY, outLineEndX, outLineEndY)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="TranslateLineInWorldCoordinateAndConvertBack">
<parameters>
<parameter id="distance"/>
<parameter id="isVertical">
<sem_type>string</sem_type>
</parameter>
<parameter id="lineEndX"/>
<parameter id="lineEndY"/>
<parameter id="lineStartX"/>
<parameter id="lineStartY"/>
<parameter id="mapToImage"/>
<parameter id="mapToWorld"/>
<parameter id="outLineEndX"/>
<parameter id="outLineEndY"/>
<parameter id="outLineStartX"/>
<parameter id="outLineStartY"/>
</parameters>
</docu>
</procedure>
<procedure name="MakeParallelLine">
<interface>
<ic>
<par name="lineStartX" base_type="ctrl" dimension="0"/>
<par name="lineStartY" base_type="ctrl" dimension="0"/>
<par name="lineEndX" base_type="ctrl" dimension="0"/>
<par name="lineEndY" base_type="ctrl" dimension="0"/>
<par name="offset" base_type="ctrl" dimension="0"/>
<par name="isVertical" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="outLineStartX" base_type="ctrl" dimension="0"/>
<par name="outLineStartY" base_type="ctrl" dimension="0"/>
<par name="outLineEndX" base_type="ctrl" dimension="0"/>
<par name="outLineEndY" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>if(isVertical == 'true')</l>
<l>    TranslateLineNotVertical (lineStartY, lineStartX, lineEndY, lineEndX, offset, outLineStartY, outLineStartX, outLineEndY, outLineEndX)</l>
<l>else</l>
<l>    TranslateLineNotVertical (lineStartX, lineStartY, lineEndX, lineEndY, offset, outLineStartX, outLineStartY, outLineEndX, outLineEndY)</l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="MakeParallelLine">
<parameters>
<parameter id="isVertical">
<description lang="zh_CN">Whether the line is near or actually vertical</description>
<sem_type>string</sem_type>
</parameter>
<parameter id="lineEndX"/>
<parameter id="lineEndY"/>
<parameter id="lineStartX"/>
<parameter id="lineStartY"/>
<parameter id="offset">
<description lang="zh_CN">Positive direction points outward from (0,0)</description>
<sem_type>real</sem_type>
</parameter>
<parameter id="outLineEndX"/>
<parameter id="outLineEndY"/>
<parameter id="outLineStartX"/>
<parameter id="outLineStartY"/>
</parameters>
</docu>
</procedure>
<procedure name="TranslateLineNotVertical">
<interface>
<ic>
<par name="lineStartX" base_type="ctrl" dimension="0"/>
<par name="lineStartY" base_type="ctrl" dimension="0"/>
<par name="lineEndX" base_type="ctrl" dimension="0"/>
<par name="lineEndY" base_type="ctrl" dimension="0"/>
<par name="offset" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="outLineStartX" base_type="ctrl" dimension="0"/>
<par name="outLineStartY" base_type="ctrl" dimension="0"/>
<par name="outLineEndX" base_type="ctrl" dimension="0"/>
<par name="outLineEndY" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>xDiff := lineEndX - lineStartX</l>
<l>yDiff := lineEndY - lineStartY</l>
<c></c>
<l>m := yDiff / xDiff</l>
<l>b := lineStartY - yDiff / xDiff * lineStartX</l>
<c></c>
<l>alpha := atan(m)</l>
<c></c>
<l>bIncre := offset / cos(alpha)</l>
<c></c>
<l>newB := b + bIncre</l>
<c></c>
<c></c>
<c>* sample output points</c>
<l>outLineStartX := lineStartX</l>
<l>outLineStartY := m * outLineStartX + newB</l>
<l>outLineEndX := lineEndX</l>
<l>outLineEndY := m * outLineEndX + newB</l>
<c></c>
<l>return ()</l>
</body>
<docu id="TranslateLineNotVertical">
<parameters>
<parameter id="lineEndX"/>
<parameter id="lineEndY"/>
<parameter id="lineStartX"/>
<parameter id="lineStartY"/>
<parameter id="offset"/>
<parameter id="outLineEndX"/>
<parameter id="outLineEndY"/>
<parameter id="outLineStartX"/>
<parameter id="outLineStartY"/>
</parameters>
</docu>
</procedure>
<procedure name="DistancePLInWorld">
<interface>
<ic>
<par name="lineStartX" base_type="ctrl" dimension="0"/>
<par name="lineStartY" base_type="ctrl" dimension="0"/>
<par name="lineEndX" base_type="ctrl" dimension="0"/>
<par name="lineEndY" base_type="ctrl" dimension="0"/>
<par name="ptX" base_type="ctrl" dimension="0"/>
<par name="ptY" base_type="ctrl" dimension="0"/>
<par name="mapToWorld" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="distanceWorld" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* transform image points to world points</c>
<l>affine_trans_point_2d (mapToWorld, lineStartX, lineStartY, lineStartX_World, lineStartY_World)</l>
<l>affine_trans_point_2d (mapToWorld, ptX, ptY, ptX_World, ptY_World)</l>
<l>affine_trans_point_2d (mapToWorld, lineEndX, lineEndY, lineEndX_World, lineEndY_World)</l>
<c></c>
<c>* cal world distance</c>
<l>distance_pl (ptY_World, ptX_World, lineStartY_World, lineStartX_World, lineEndY_World, lineEndX_World, distanceWorld)</l>
<l>return ()</l>
</body>
<docu id="DistancePLInWorld">
<parameters>
<parameter id="distanceWorld"/>
<parameter id="lineEndX"/>
<parameter id="lineEndY"/>
<parameter id="lineStartX"/>
<parameter id="lineStartY"/>
<parameter id="mapToWorld"/>
<parameter id="ptX"/>
<parameter id="ptY"/>
</parameters>
</docu>
</procedure>
</hdevelop>
